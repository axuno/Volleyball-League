using TournamentManager.DAL.EntityClasses;
using TournamentManager.DAL.HelperClasses;
using SD.LLBLGen.Pro.ORMSupportClasses;
using Microsoft.Extensions.Logging;
using TournamentManager.Data;
using TournamentManager.MultiTenancy;

namespace TournamentManager.Plan;

/// <summary>
/// This class manages available match dates.
/// </summary>
internal class AvailableMatchDates
{
    private readonly ITenantContext _tenantContext;
    private readonly AppDb _appDb;
    private readonly Axuno.Tools.DateAndTime.TimeZoneConverter _timeZoneConverter;

    private readonly ILogger<AvailableMatchDates> _logger;

    // available match dates from database
    private readonly EntityCollection<AvailableMatchDateEntity> _availableMatchDateEntities = new();

    // programmatically generated available match dates
    private readonly EntityCollection<AvailableMatchDateEntity> _generatedAvailableMatchDateEntities = new();

    // excluded dates
    private readonly EntityCollection<ExcludeMatchDateEntity> _excludedMatchDateEntities = new();

    internal AvailableMatchDates(ITenantContext tenantContext,
        Axuno.Tools.DateAndTime.TimeZoneConverter timeZoneConverter, ILogger<AvailableMatchDates> logger)
    {
        _tenantContext = tenantContext;
        _appDb = tenantContext.DbContext.AppDb;
        _timeZoneConverter = timeZoneConverter;
        _logger = logger;
    }

    /// <summary>
    /// Clears and loads excluded match dates and available match dates
    /// from storage.
    /// </summary>
    private async Task Initialize(CancellationToken cancellationToken)
    {
        _logger.LogDebug($"Initializing {nameof(AvailableMatchDates)}");
        _excludedMatchDateEntities.Clear();
        _excludedMatchDateEntities.AddRange(
            await _appDb.ExcludedMatchDateRepository.GetExcludedMatchDatesAsync(
                _tenantContext.TournamentContext.MatchPlanTournamentId, cancellationToken));

        _logger.LogDebug("{count} excluded match dates loaded from storage", _excludedMatchDateEntities.Count);

        _availableMatchDateEntities.Clear();
        _availableMatchDateEntities.AddRange(
            await _appDb.AvailableMatchDateRepository.GetAvailableMatchDatesAsync(
                _tenantContext.TournamentContext.MatchPlanTournamentId, cancellationToken));

        _logger.LogDebug("{count} available match dates loaded from storage", _availableMatchDateEntities.Count);

        _generatedAvailableMatchDateEntities.Clear();
    }


    /// <summary>
    /// Removes entries in AvailableMatchDates database table.
    /// </summary>
    /// <param name="clear">Which entries to delete for the tournament.</param>
    /// <param name="cancellationToken"></param>
    /// <returns>Returns the number of deleted records.</returns>
    public async Task<int> ClearAsync(MatchDateClearOption clear, CancellationToken cancellationToken)
    {
        var deleted = 0;

        // tournament is always in the filter
        var filterAvailable = new RelationPredicateBucket();
        filterAvailable.PredicateExpression.Add(AvailableMatchDateFields.TournamentId ==
                                                _tenantContext.TournamentContext.MatchPlanTournamentId);

        if (clear == MatchDateClearOption.All)
        {
            deleted = await _appDb.GenericRepository.DeleteEntitiesDirectlyAsync(typeof(AvailableMatchDateEntity),
                null!, cancellationToken);
            _generatedAvailableMatchDateEntities.Clear();
        }
        else if (clear == MatchDateClearOption.OnlyAutoGenerated)
        {
            filterAvailable.PredicateExpression.AddWithAnd(AvailableMatchDateFields.IsGenerated == true);
            deleted = await _appDb.GenericRepository.DeleteEntitiesDirectlyAsync(typeof(AvailableMatchDateEntity),
                filterAvailable, cancellationToken);
            _generatedAvailableMatchDateEntities.Clear();
        }
        else if (clear == MatchDateClearOption.OnlyManual)
        {
            filterAvailable.PredicateExpression.AddWithAnd(AvailableMatchDateFields.IsGenerated == false);
            deleted = await _appDb.GenericRepository.DeleteEntitiesDirectlyAsync(typeof(AvailableMatchDateEntity),
                filterAvailable, cancellationToken);
        }

        return deleted;
    }

    /// <summary>
    /// Checks the <see cref="TeamEntity"/> for <see cref="TeamEntity.MatchDayOfWeek"/>,
    /// <see cref="TeamEntity.MatchTime"/> and <see cref="TeamEntity.VenueId"/> for not <see langword="null"/>.
    /// </summary>
    private bool IsVenueAndDateDefined(TeamEntity team)
    {
        return team is { MatchDayOfWeek: not null, MatchTime: not null, VenueId: not null };
    }

    /// <summary>
    /// Verifies, that the given <paramref name="matchDateTimeUtc"></paramref> is within the <see cref="RoundLegEntity"/> date
    /// bounderies, <b>and</b> it is not excluded, <b>and</b> the venue is not occupied by another match.
    /// </summary>
    private async Task<bool> IsDateUsable(DateTime matchDateTimeUtc, RoundLegEntity roundLeg, TeamEntity team, CancellationToken cancellationToken)
    {
        var plannedDuration = _tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch;

        // Todo: This code creates heavy load on the database
        return IsDateWithinRoundLegDateTime(roundLeg, matchDateTimeUtc)
            && !IsExcludedDate(matchDateTimeUtc, roundLeg.RoundId, team.Id)
            && !await IsVenueOccupiedByMatchAsync(
                new DateTimePeriod(matchDateTimeUtc, matchDateTimeUtc.Add(plannedDuration)),
                team.VenueId!.Value, cancellationToken);
    }


    /// <summary>
    /// Generate available match dates for teams where 
    /// <see cref="TeamEntity.MatchDayOfWeek"/>, <see cref="TeamEntity.MatchTime"/>, <see cref="TeamEntity.VenueId"/>
    /// are not <see langword="null"/>.
    /// </summary>
    /// <param name="round"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    public async Task GenerateNewAsync(RoundEntity round, CancellationToken cancellationToken)
    {
        await Initialize(cancellationToken);

        // Venues will later be assigned to these teams on a rotating basis
        var listTeamsWithSameVenue = GetListOfTeamsWithSameVenue(round);
        
        foreach (var roundLeg in round.RoundLegs)
        {
            var startDate = DateTime.SpecifyKind(roundLeg.StartDateTime, DateTimeKind.Utc);
            var endDate = DateTime.SpecifyKind(roundLeg.EndDateTime, DateTimeKind.Utc);

            foreach (var teamsWithSameVenue in listTeamsWithSameVenue)
            {
                var team = teamsWithSameVenue[0];

                // get the first possible match date equal or after the leg's starting date
                var matchDate = IncrementDateUntilDayOfWeek(startDate, (DayOfWeek) team.MatchDayOfWeek!);

                // process the period of a leg
                var teamIndex = 0;
                while (matchDate <= endDate)
                {
                    team = teamsWithSameVenue[teamIndex];

                    // if there is more than one team per venue with same weekday and match time,
                    // match dates will be assigned alternately
                    var matchDateTimeUtc = _timeZoneConverter.ToUtc(matchDate.Date.Add(team.MatchTime!.Value));

                    // check whether the calculated date 
                    // is within the borders of round legs (if any) and is not marked as excluded

                    if (await IsDateUsable(matchDateTimeUtc, roundLeg, team, cancellationToken))
                    {
                        var av = new AvailableMatchDateEntity
                        {
                            TournamentId = _tenantContext.TournamentContext.MatchPlanTournamentId,
                            HomeTeamId = team.Id,
                            VenueId = team.VenueId!.Value,
                            MatchStartTime = matchDateTimeUtc,
                            MatchEndTime =
                                matchDateTimeUtc.Add(_tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch),
                            IsGenerated = true
                        };

                        _generatedAvailableMatchDateEntities.Add(av);
                    }

                    if (teamsWithSameVenue.Count > 1)
                    {
                        teamIndex++;
                        if (teamIndex >= teamsWithSameVenue.Count) teamIndex = 0;
                    }

                    matchDate = matchDate.Date.AddDays(7);
                }
            }
        }

        _logger.LogDebug("Generated {Count} UTC dates for HomeTeams:", _generatedAvailableMatchDateEntities.Count);
        _logger.LogDebug("{Generated}\n", _generatedAvailableMatchDateEntities.Select(gen => (gen.HomeTeamId, gen.MatchStartTime)));

        // save to the persistent storage
        // await _appDb.GenericRepository.SaveEntitiesAsync(_generatedAvailableMatchDateEntities, true, false, cancellationToken);
    }

    /// <summary>
    /// Make a list of teams of the same round and with the same venue AND weekday AND overlapping match time 
    /// </summary>
    private List<EntityCollection<TeamEntity>> GetListOfTeamsWithSameVenue(RoundEntity round)
    {
        var listTeamsWithSameVenue = new List<EntityCollection<TeamEntity>>();

        var teamIdProcessed = new List<long>();
        foreach (var team in round.TeamCollectionViaTeamInRound)
        {
            // the collection will contain at least one team
            var teams = GetTeamsWithSameVenueAndMatchTime(team, round);
            if (!IsVenueAndDateDefined(teams[0]) || teamIdProcessed.Contains(teams[0].Id)) continue;

            listTeamsWithSameVenue.Add(teams);
            foreach (var t in teams)
                if (!teamIdProcessed.Contains(t.Id))
                    teamIdProcessed.Add(t.Id);
        }

        return listTeamsWithSameVenue;
    }

    private async Task<bool> IsVenueOccupiedByMatchAsync(DateTimePeriod matchTime, long venueId,
        CancellationToken cancellationToken)
    {
        return (await _appDb.VenueRepository.GetOccupyingMatchesAsync(venueId, matchTime,
            _tenantContext.TournamentContext.MatchPlanTournamentId, cancellationToken)).Any();
    }

    private static bool IsDateWithinRoundLegDateTime(RoundLegEntity leg, DateTime queryDate)
    {
        return queryDate.Date >= leg.StartDateTime.Date && queryDate.Date <= leg.EndDateTime.Date;
    }
        
    private static DateTime IncrementDateUntilDayOfWeek(DateTime date, DayOfWeek dayOfWeek)
    {
        var count = 0;
        while (date.DayOfWeek != dayOfWeek && count++ <= 7)
            date = date.AddDays(1);

        return date;
    }

    /// <summary>
    /// Checks whether the <paramref name="queryDate"/> is excluded either for a tournament OR optionally for a round or team.
    /// If the excluded table row contains a <paramref name="roundId"/> or <paramref name="teamId"/>, it is NOT excluded for the tournament,
    /// but only for the team or round.
    /// </summary>
    /// <remarks>
    /// Same behavior as with <see cref="ExcludedMatchDateRepository.GetExcludedMatchDateAsync"/>.
    /// </remarks>
    /// <param name="queryDate">Date to test, whether it is excluded.</param>
    /// <param name="roundId">OR excluded on the round level. If <see langword="null" />, there is no round restriction.</param>
    /// <param name="teamId">OR excluded on the team level. If <see langword="null" />, there is no team restriction.</param>
    /// <returns>Returns <see langword="true"/>, if criteria match, else <see langword="false"/>.</returns>
    private bool IsExcludedDate(DateTime queryDate, long? roundId, long? teamId)
    {
        return
            // Excluded for the whole tournament...
            _excludedMatchDateEntities.Any(
                excl => queryDate >= excl.DateFrom && queryDate <= excl.DateTo &&
                        excl.TournamentId == _tenantContext.TournamentContext.MatchPlanTournamentId && !excl.RoundId.HasValue &&
                        !excl.TeamId.HasValue)
            ||
            // OR excluded for a round...
            _excludedMatchDateEntities.Any(
                excl => queryDate >= excl.DateFrom && queryDate <= excl.DateTo &&
                        excl.TournamentId == _tenantContext.TournamentContext.MatchPlanTournamentId && excl.RoundId.HasValue &&
                        roundId.HasValue && excl.RoundId == roundId)
            ||
            // OR excluded for a team
            _excludedMatchDateEntities.Any(
                excl => queryDate >= excl.DateFrom && queryDate <= excl.DateTo &&
                        excl.TournamentId == _tenantContext.TournamentContext.MatchPlanTournamentId && excl.TeamId.HasValue &&
                        teamId.HasValue && excl.TeamId == teamId)
            ;
    }

    public List<DateTime> GetGeneratedAndManualAvailableMatchDateDays(RoundLegEntity leg)
    {
        var result = _generatedAvailableMatchDateEntities.Union(_availableMatchDateEntities)
            .Where(gen => gen.TournamentId == _tenantContext.TournamentContext.MatchPlanTournamentId
                          && gen.MatchStartTime >= leg.StartDateTime.Date &&
                          gen.MatchStartTime <= leg.EndDateTime.AddDays(1).AddSeconds(-1))
            .OrderBy(gen => gen.MatchStartTime)
            .Select(gen => gen.MatchStartTime.Date)
            .Distinct()
            .ToList();
        return result;
    }

    public List<AvailableMatchDateEntity> GetGeneratedAndManualAvailableMatchDates(long homeTeamId,
        DateTimePeriod datePeriod, List<DateTime>? excludedDates)
    {
        if (datePeriod is not { Start: not null, End: not null }) throw new ArgumentNullException(nameof(datePeriod));

        var result = _generatedAvailableMatchDateEntities.Union(_availableMatchDateEntities)
            .Where(gen => gen.TournamentId == _tenantContext.TournamentContext.MatchPlanTournamentId
                          && gen.HomeTeamId == homeTeamId && gen.MatchStartTime >= datePeriod.Start.Value.Date &&
                          gen.MatchStartTime <=
                          datePeriod.End.Value.Date.AddDays(1).AddSeconds(-1))
            .OrderBy(gen => gen.MatchStartTime);

        if (excludedDates is { Count: > 0 })
            return result.Where(dates => !excludedDates.Contains(dates.MatchStartTime.Date))
                .OrderBy(dates => dates.MatchStartTime).ToList();

        return result.ToList();
    }

    /// <summary>
    /// Gets the teams in a round with the same <see cref="TeamEntity.VenueId"/>, <see cref="TeamEntity.MatchDayOfWeek"/>
    /// and overlapping <see cref="TeamEntity.MatchTime"/>.
    /// </summary>
    private EntityCollection<TeamEntity> GetTeamsWithSameVenueAndMatchTime(TeamEntity team, RoundEntity round)
    {
        var resultTeams = new EntityCollection<TeamEntity>();

        var teamStartTime = team.MatchTime;
        var teamEndTime = teamStartTime?.Add(_tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch);

        // get a list of other teams in this round with same venue and match day-of-the-week
        var otherTeams = round.TeamCollectionViaTeamInRound.FindMatches((TeamFields.VenueId == team.VenueId) &
                                                                        (TeamFields.MatchDayOfWeek ==
                                                                         team.MatchDayOfWeek) &
                                                                        (TeamFields.Id != team.Id));

        foreach (var index in otherTeams)
        {
            var otherStartTime = round.TeamCollectionViaTeamInRound[index].MatchTime;
            var otherEndTime = otherStartTime?.Add(_tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch);

            if (otherStartTime <= teamStartTime && otherEndTime >= teamStartTime ||
                otherStartTime <= teamEndTime && otherEndTime >= teamEndTime)
                resultTeams.Add(round.TeamCollectionViaTeamInRound[index]);
        }

        // list is expected to contain at least one team
        resultTeams.Add(team);

        return resultTeams;
    }
}
