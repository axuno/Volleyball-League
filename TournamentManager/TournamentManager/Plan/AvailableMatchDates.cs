using System;
using System.Collections.Generic;
using TournamentManager.DAL;
using TournamentManager.DAL.EntityClasses;
using TournamentManager.DAL.FactoryClasses;
using TournamentManager.DAL.HelperClasses;
using TournamentManager.DAL.Linq;
using SD.LLBLGen.Pro.ORMSupportClasses;
using System.Data;
using System.Linq;
using TournamentManager.Data;

namespace TournamentManager.Plan
{
	public class AvailableMatchDates
	{
	    private readonly AppDb _appDb;
		private MatchPlanner _matchPlanner;
		private EntityCollection<AvailableMatchDateEntity> _availableMatchDate;

		internal AvailableMatchDates(AppDb appDb, MatchPlanner matchPlanner)
		{
		    _appDb = appDb;
			_matchPlanner = matchPlanner;
			_availableMatchDate = new EntityCollection<AvailableMatchDateEntity>(new AvailableMatchDateEntityFactory());
		}

		/// <summary>
		/// Removes all entries in AvailableMatchDates database table.
		/// </summary>
		/// <param name="clear">Which entries to delete for the tournament.</param>
		/// <returns>Returns the number of deleted records.</returns>
        internal int Clear(ClearMatchDates clear)
		{
			int deleted = 0;

			// tournament is always in the filter
			var filterAvailable = new RelationPredicateBucket();
			filterAvailable.PredicateExpression.Add(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);

			if (clear == ClearMatchDates.All)
			{
				deleted = _matchPlanner.Adapter.DeleteEntitiesDirectly(typeof(AvailableMatchDateEntity), null);
			}
			else if (clear == ClearMatchDates.OnlyAutoGenerated)
			{
				filterAvailable.PredicateExpression.AddWithAnd(AvailableMatchDateFields.IsGenerated == true);
				deleted = _matchPlanner.Adapter.DeleteEntitiesDirectly(typeof(AvailableMatchDateEntity), filterAvailable);
			}
			else if (clear == ClearMatchDates.OnlyManual)
			{
				filterAvailable.PredicateExpression.AddWithAnd(AvailableMatchDateFields.IsGenerated == false);
				deleted = _matchPlanner.Adapter.DeleteEntitiesDirectly(typeof(AvailableMatchDateEntity), filterAvailable);
			}

			return deleted;
		}


		internal void GenerateNew(RoundEntity round)
		{
			var teamIdProcessed = new List<long>();
			var listTeamsWithSameVenue = new List<EntityCollection<TeamEntity>>();

			// Make a list of teams of the same round and with the same venue + weekday + match time
			// Venues will later be assigned to these teams in an alternating way
			foreach (var team in round.TeamCollectionViaTeamInRound)
			{
				// the collection will contain at least one team
				EntityCollection<TeamEntity> teams = GetTeamsWithSameVenueAndMatchTime(team, round);
				if (!teamIdProcessed.Contains(teams[0].Id))
				{
					listTeamsWithSameVenue.Add(teams);
					foreach (var t in teams)
					{
						if (!teamIdProcessed.Contains(t.Id))
							teamIdProcessed.Add(t.Id);
					}
				}
			}

			foreach (var roundLeg in round.RoundLegs)
			{
				DateTime startDate = roundLeg.StartDateTime;
				DateTime endDate = roundLeg.EndDateTime;
				var matchDate = new DateTime();

				foreach (var teamsWithSameVenue in listTeamsWithSameVenue)
				{
					int teamIndex = 0;
					
					// get the first possible match date equal or after the leg's starting date
					matchDate = IncrementDateUntilDayOfWeek(startDate, (DayOfWeek)teamsWithSameVenue[teamIndex].MatchDayOfWeek);

					// process the period of a leg
					while (matchDate <= endDate)
					{
						// if there is more than one team per venue with same weekday and match time,
						// match dates will be assigned alternately
						TeamEntity team = teamsWithSameVenue[teamIndex];
						DateTime matchDateAndTime = DateTime.Parse(string.Concat(matchDate.ToShortDateString(), " ", team.MatchTime));

						// check whether the calculated date 
						// is within the borders of round legs (if any) and is not marked as excluded
						if (IsDateWithinRoundLegDateTime(roundLeg, matchDate)
						    && !IsExcludedDate(matchDate, round.Id, team.Id)
                            && !IsVenueOccupiedByMatch(new DateTimePeriod(matchDateAndTime, matchDateAndTime.Add(_matchPlanner.PlannedDurationOfMatch)), team.VenueId.Value))
						{
							var av = new AvailableMatchDateEntity();
							av.TournamentId = _matchPlanner.Tournament.Id;
							av.HomeTeamId = team.Id;
							av.VenueId = team.Venue.Id;
							av.MatchStartTime = matchDateAndTime;
                            av.MatchEndTime = matchDateAndTime.Add(_matchPlanner.PlannedDurationOfMatch);
							av.IsGenerated = true;
							av.CreatedOn = DateTime.Now;

							_availableMatchDate.Add(av);
							teamIndex = (++teamIndex >= teamsWithSameVenue.Count) ? 0 : teamIndex;
						}
						matchDate = matchDate.Date.AddDays(7);
					}
				}
			}
			
			// save to the persistent storage
			_matchPlanner.Adapter.SaveEntityCollection(_availableMatchDate, true, false);
		}

        private bool IsVenueOccupiedByMatch(DateTimePeriod matchTime, long venueId)
        {
			return _appDb.VenueRepository.GetOccupyingMatches(venueId, matchTime, _matchPlanner.Tournament.Id).Any();
        }


        [Obsolete("The method is not in use any more in favour of IsVenueOccupiedByMatch(DateSegment matchTime, VenueEntity venue).", true)]
		private bool IsVenueOccupiedByMatch(DateTime matchStartTime, DateTime matchEndTime, long venueId)
		{
			EntityCollection<MatchEntity> match;
			return IsVenueOccupiedByMatch(matchStartTime, matchEndTime, venueId, out match);
		}

        [Obsolete("The method is not in use any more in favour of Selector.Venue.GetOccupyingMatches.", true)]
		private bool IsVenueOccupiedByMatch(DateTime matchStartTime, DateTime matchEndTime, long venueId, out EntityCollection<MatchEntity> match)
		{
			var filter = new RelationPredicateBucket();
			IPrefetchPath2 prefetchPathMatch = new PrefetchPath2(EntityType.MatchEntity);
			prefetchPathMatch.Add(MatchEntity.PrefetchPathHomeTeam);
			prefetchPathMatch.Add(MatchEntity.PrefetchPathGuestTeam);


			// all expressions are checked against the test database and work, 2008-07-09/NB

			// PlannedStart with Venue
			filter.PredicateExpression.Add(
				((MatchFields.PlannedStart <= matchStartTime & MatchFields.PlannedEnd >= matchStartTime)
				 | MatchFields.PlannedStart <= matchEndTime & MatchFields.PlannedEnd >= matchEndTime)
				& MatchFields.VenueId == venueId & MatchFields.OrigPlannedStart == DBNull.Value & MatchFields.OrigVenueId == DBNull.Value);

			// AuxPlannedStart with Venue
			filter.PredicateExpression.AddWithOr(
				((MatchFields.OrigPlannedStart <= matchStartTime & MatchFields.OrigPlannedEnd >= matchStartTime)
				 | MatchFields.OrigPlannedStart <= matchEndTime & MatchFields.OrigPlannedEnd >= matchEndTime)
				& MatchFields.VenueId == venueId & MatchFields.OrigPlannedStart != DBNull.Value & MatchFields.OrigVenueId == DBNull.Value);

			// PlannedStart with AuxVenue
			filter.PredicateExpression.AddWithOr(
				((MatchFields.PlannedStart <= matchStartTime & MatchFields.PlannedEnd >= matchStartTime)
				 | MatchFields.PlannedStart <= matchEndTime & MatchFields.PlannedEnd >= matchEndTime)
				& MatchFields.OrigVenueId == venueId & MatchFields.OrigPlannedStart == DBNull.Value & MatchFields.OrigVenueId != DBNull.Value);

			// AuxPlannedStart with AuxVenue
			filter.PredicateExpression.AddWithOr(
				((MatchFields.OrigPlannedStart <= matchStartTime & MatchFields.OrigPlannedEnd >= matchStartTime)
				 | MatchFields.OrigPlannedStart <= matchEndTime & MatchFields.OrigPlannedEnd >= matchEndTime)
				& MatchFields.OrigVenueId == venueId & MatchFields.OrigPlannedStart != DBNull.Value & MatchFields.OrigVenueId != DBNull.Value);
			
			match = new EntityCollection<MatchEntity>(new MatchEntityFactory());
			_matchPlanner.Adapter.FetchEntityCollection(match, filter, prefetchPathMatch);
			
			return match.Count > 0;

			// return (_matchPlanner.Adapter.GetDbCount(new MatchEntityFactory().CreateFields(), bucket) > 0);
		}

	
		private bool IsDateWithinRoundLegDateTime(RoundLegEntity leg, DateTime queryDate)
		{
			return (queryDate.Date >= leg.StartDateTime.Date && queryDate.Date <= leg.EndDateTime.Date);
		}
		

		private DateTime IncrementDateUntilDayOfWeek(DateTime date, DayOfWeek dayOfWeek)
		{
			int count = 0;
			while (date.DayOfWeek != dayOfWeek && count++ < 8)
				date = date.AddDays(1);

			if (count >= 7)
				throw new Exception("Illegal target weekday. Target date cannot be determined.");

			return date;
		}

        /// <summary>
        /// Gets a collection of excluded date ranges, the requested queryDate is in between.
        /// </summary>
        /// <param name="queryDate">Date to test, whether it is excluded.</param>
        /// <param name="roundId">OR excluded on the round level. If null, there is no round restriction.</param>
        /// <param name="teamId">OR excluded on the team level. If null, there is no team restriction.</param>
        /// <returns>Returns true, if queryDate was found, else false.</returns>
		private bool IsExcludedDate(DateTime queryDate, long roundId, long teamId)
		{
            return GetExcludedDates(queryDate, _matchPlanner.Tournament.Id, roundId, teamId).Count > 0;
		}


		internal List<DateTime> GetAllAvailableMatchDays(RoundLegEntity roundLeg)
		{
			LinqMetaData metaData = new LinqMetaData(_matchPlanner.Adapter);

			return (from dates in metaData.AvailableMatchDate
			        where
			        	dates.TournamentId == _matchPlanner.Tournament.Id &&
						(dates.MatchStartTime >= roundLeg.StartDateTime.Date && dates.MatchStartTime <= roundLeg.EndDateTime.Date.AddDays(1).AddSeconds(-1))
			        orderby dates.MatchStartTime
			        select dates.MatchStartTime.Date).Distinct().ToList();
		}

		[Obsolete("Use List<DateTime> GetAllAvailableMatchDays(RoundLegEntity roundLeg)")]
		internal DataTable GetAllAvailableMatchDays_(RoundLegEntity roundLeg)
		{
			var fields = new ResultsetFields(1);
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 0, "MatchStartTime");
			fields[0].ExpressionToApply = new DbFunctionCall("(DATE({0}) + INTERVAL 0 SECOND)", new object[] { AvailableMatchDateFields.MatchStartTime });

			IRelationPredicateBucket bucket = new RelationPredicateBucket(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);

			// date within round leg limits
			IPredicateExpression dateFilter = new PredicateExpression(new FieldBetweenPredicate(fields[0], null, roundLeg.StartDateTime.Date, roundLeg.EndDateTime.Date));
			bucket.PredicateExpression.AddWithAnd(dateFilter);

			ISortExpression sortClause = new SortExpression(new SortClause(fields[0], null, SortOperator.Ascending));

			var dynamicList = new DataTable();
			_matchPlanner.Adapter.FetchTypedList(fields, dynamicList, bucket, 0, sortClause, true, null);

			return dynamicList;
		}

		internal List<AvailableMatchDateEntity> GetAvailableMatchDays(long homeTeamId, DateTimePeriod dateSegment, List<DateTime> excludedDates)
		{
			LinqMetaData metaData = new LinqMetaData(_matchPlanner.Adapter);

			var result = (from dates in metaData.AvailableMatchDate
					where
						dates.TournamentId == _matchPlanner.Tournament.Id &&
						dates.HomeTeamId == homeTeamId &&
						(dates.MatchStartTime >= dateSegment.Start.Value.Date && dates.MatchStartTime <= dateSegment.End.Value.Date.AddDays(1).AddSeconds(-1))
					orderby dates.MatchStartTime
					select dates).ToList();

			if (excludedDates != null && excludedDates.Count > 0)
			{
				return result.Where(dates => !excludedDates.Contains(dates.MatchStartTime.Date)).OrderBy(dates => dates.MatchStartTime).ToList();
			}

			return result;
		}

		[Obsolete("Use List<AvailableMatchDateEntity> GetAvailableMatchDays(long homeTeamId, DateSegment dateSegment, List<DateTime> excludedDates)")]
		internal DataTable GetAvailableMatchDays_(long homeTeamId, DateTimePeriod dateSegment, List<DateTime> excludedDates)
		{
			/* Generate Query:
			 * SELECT DISTINCT (DATE(`available_match_date`.MatchDateTime) + INTERVAL 0 SECOND) AS `MatchDate` FROM `available_match_date` 
			 * WHERE ( ( `available_match_date`.TournamentId = @TournamentId1 AND `available_match_date`.HomeTeamId = @HomeTeamId2 
			 * AND ( (DATE(`available_match_date`.MatchDateTime) + INTERVAL 0 SECOND) BETWEEN @MatchDate3 AND @MatchDate4) 
			 * AND ( (DATE(`available_match_date`.MatchDateTime) + INTERVAL 0 SECOND) NOT IN (@MatchDate5)))) ORDER BY MatchDate ASC
			 * 
			 * Attention: Date parameters always have 00:00:00 included in LLBLGenPro, that's why we have to add 0 seconds to date fields!
			 */
			
			var fields = new ResultsetFields(2);
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 0, "MatchStartTime");
			fields.DefineField(AvailableMatchDateFields.Id, 1);
			// truncate the time part of the match date
			fields[0].ExpressionToApply = new DbFunctionCall("(DATE({0}) + INTERVAL 0 SECOND)", new object[] { AvailableMatchDateFields.MatchStartTime });

			// General limitation: TournamentId
			IRelationPredicateBucket bucket = new RelationPredicateBucket(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);
			bucket.PredicateExpression.AddWithAnd(AvailableMatchDateFields.HomeTeamId == homeTeamId);

			// date within desired segment
			IPredicateExpression dateFilter = new PredicateExpression(new FieldBetweenPredicate(fields[0], null, dateSegment.Start, dateSegment.End));
			bucket.PredicateExpression.AddWithAnd(dateFilter);

			// dates NOT IN excluded dates (matches already assigned)
			if (excludedDates.Count != 0)
			{
				IPredicateExpression excludedDatesFilter = new PredicateExpression(new FieldCompareRangePredicate(fields[0], null, true, excludedDates.ToArray()));
				bucket.PredicateExpression.AddWithAnd(excludedDatesFilter);
			}

			ISortExpression sortClause = new SortExpression(new SortClause(fields[0], null, SortOperator.Ascending));

			var dynamicList = new DataTable();
			_matchPlanner.Adapter.FetchTypedList(fields, dynamicList, bucket, 0, sortClause, false, null);

			return dynamicList;
		}

		private EntityCollection<TeamEntity> GetTeamsWithSameVenueAndMatchTime(TeamEntity team, RoundEntity round)
		{
			var resultTeams = new EntityCollection<TeamEntity>();

            TimeSpan? teamStartTime = team.MatchTime;
            TimeSpan? teamEndTime = teamStartTime?.Add(_matchPlanner.PlannedDurationOfMatch);

			// first get a list of other teams with same venue and match day of the week
			List<int> tmpTeams = round.TeamCollectionViaTeamInRound.FindMatches(TeamFields.VenueId == team.VenueId & TeamFields.MatchDayOfWeek == (int)team.MatchDayOfWeek & TeamFields.Id != team.Id);

			foreach (var index in tmpTeams)
			{
                TimeSpan? otherStartTime = round.TeamCollectionViaTeamInRound[index].MatchTime;
                TimeSpan? otherEndTime = otherStartTime?.Add(_matchPlanner.PlannedDurationOfMatch);

				if ((otherStartTime <= teamStartTime && otherEndTime >= teamStartTime) || (otherStartTime <= teamEndTime && otherEndTime >= teamEndTime))
				{
					resultTeams.Add(round.TeamCollectionViaTeamInRound[index]);
				}
			}

			// list is expected to contain at least one team
			resultTeams.Add(team);

			return resultTeams;
		}

        internal void GenerateExcludedDates(string specialHolidaysXmlFile)
        {
            var allRoundLegs = (_matchPlanner.Tournament.Rounds.SelectMany(r => r.RoundLegs.Select(rl => rl))).ToList();
			var minDate = allRoundLegs.Min(leg => leg.StartDateTime);
            var maxDate = allRoundLegs.Min(leg => leg.EndDateTime);

			var minYear = minDate.Year;

            var holidays = new List<Axuno.Tools.GermanHoliday>();

            while (minYear <= maxDate.Year)
            {
                var hd = new Axuno.Tools.GermanHolidays(minYear);
                
                if (!string.IsNullOrEmpty(specialHolidaysXmlFile))
                    hd.Load(specialHolidaysXmlFile);
                
                holidays.AddRange(
                    hd.GetFiltered(
                        h =>
                        (h.PublicHolidayStateIds.Count == 0 ||
                         h.PublicHolidayStateIds.Contains(Axuno.Tools.GermanFederalStates.Id.Bayern)) &&
                        (h.Type == Axuno.Tools.GermanHolidays.Type.Public || h.Type == Axuno.Tools.GermanHolidays.Type.Custom ||
                         h.Type == Axuno.Tools.GermanHolidays.Type.School)));
                
                minYear++;
            }

            // remove existing excluded dates for the tournament
            var filter = new RelationPredicateBucket(ExcludeMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);

            var adapter = _appDb.DbContext.GetNewAdapter();
            adapter.DeleteEntitiesDirectly(typeof(ExcludeMatchDateEntity), filter);

            foreach (var h in holidays)
            {
                // save holidays which are within the tournaments' legs
                if (h.Date >= minDate && h.Date <= maxDate)
                {
                    var excluded = new ExcludeMatchDateEntity();
                    excluded.TournamentId = _matchPlanner.Tournament.Id;
                    excluded.RoundId = null;
                    excluded.TeamId = null;
                    excluded.DateFrom = excluded.DateTo = h.Date;
                    excluded.Reason = h.Name;
                    excluded.CreatedOn = DateTime.Now;
                    excluded.ModifiedOn = excluded.CreatedOn;
                    adapter.SaveEntity(excluded);
                }
            }
        }

        public virtual EntityCollection<ExcludeMatchDateEntity> GetExcludedDates(DateTime queryDate, long? tournamentId,
            long? roundId, long? teamId)
        {
            var filter = new RelationPredicateBucket();

            var scopeFilter = new PredicateExpression();

            // Condition 1: excluded on tournament level
            if (tournamentId != null)
                scopeFilter.AddWithOr(ExcludeMatchDateFields.TournamentId == tournamentId);

            // Condition 2: OR excluded on round level
            if (roundId != null)
                scopeFilter.AddWithOr(ExcludeMatchDateFields.RoundId == roundId);

            // Condition 3: OR excluded on team level
            if (teamId != null)
                scopeFilter.AddWithOr(ExcludeMatchDateFields.TeamId == teamId);

            filter.PredicateExpression.Add(scopeFilter);

            // Condition 4: AND date between from/to dates (including limiting dates)
            var dateFilter = new PredicateExpression();
            dateFilter.AddWithAnd(ExcludeMatchDateFields.DateFrom <= queryDate.Date);
            dateFilter.AddWithAnd(ExcludeMatchDateFields.DateTo >= queryDate.Date);
            filter.PredicateExpression.Add(dateFilter);

            var excluded = new EntityCollection<ExcludeMatchDateEntity>(new ExcludeMatchDateEntityFactory());
            using (var da = _appDb.DbContext.GetNewAdapter())
            {
                da.FetchEntityCollection(excluded, filter);
                da.CloseConnection();
            }

            //(return adapter.GetDbCount(new ExcludeMatchDateEntityFactory().CreateFields(), filter) == 0);

            return excluded;
        }

		/*
		[Obsolete("It works but it is not usable for desired purpose :)")]
		private DataTable GetAvailableMatchDays(List<long> homeTeams, DateSegment dateSegment)
		{
			var fields = new ResultsetFields(3);
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 0, "MatchStartTime");
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 1, "Week");
			fields.DefineField(AvailableMatchDateFields.Id, 2, "Count", string.Empty, AggregateFunction.CountRow);

			// truncate the time part of the match date
			fields[0].ExpressionToApply = new DbFunctionCall("DATE({0})", new object[] { AvailableMatchDateFields.MatchStartTime });
			// calendar week DIN 1355 / ISO 8601:
			fields[1].ExpressionToApply = new DbFunctionCall("WEEK({0},1)", new object[] { AvailableMatchDateFields.MatchStartTime });

			IRelationPredicateBucket bucket = new RelationPredicateBucket(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);

			IPredicateExpression dateFilter = new PredicateExpression(new FieldBetweenPredicate(AvailableMatchDateFields.MatchStartTime, null, dateSegment.Start, dateSegment.End));
			IPredicateExpression teamFilter = new PredicateExpression(new FieldCompareRangePredicate(AvailableMatchDateFields.HomeTeamId, null, homeTeams.ToArray()));

			bucket.PredicateExpression.AddWithAnd(dateFilter);
			bucket.PredicateExpression.AddWithAnd(teamFilter);

			IGroupByCollection groupByClause = new GroupByCollection();
			groupByClause.Add(fields[0]);
			IPredicateExpression havingFilter = new PredicateExpression();
			havingFilter.Add(new FieldCompareValuePredicate(fields[2], null, ComparisonOperator.GreaterEqual, 0));
			groupByClause.HavingClause = havingFilter;

			ISortExpression sortClause = new SortExpression(new SortClause(fields[2], null, SortOperator.Ascending));

			var dynamicList = new DataTable();
			_matchPlanner.Adapter.FetchTypedList(fields, dynamicList, bucket, 0, sortClause, false, groupByClause);

			return dynamicList;
		}

		[Obsolete("Created just for test purposes.")]
		internal DataTable GetList(IPredicate filter)
		{
			var fields = new ResultsetFields(3);
			fields.DefineField(AvailableMatchDateFields.HomeTeamId, 0);
			fields.DefineField(AvailableMatchDateFields.VenueId, 1);
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 2);
			IRelationPredicateBucket bucket = new RelationPredicateBucket(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);
			bucket.PredicateExpression.AddWithAnd(filter);

			var dynamicList = new DataTable();
			_matchPlanner.Adapter.FetchTypedList(fields, dynamicList, bucket);

			return dynamicList;
		}

		[Obsolete("Created just for test purposes.")]
        internal DataTable GetMinMaxDateList(IPredicate filter)
		{
			var fields = new ResultsetFields(3);
			//fields.DefineField(AvailableMatchDateFields.HomeTeamId, 0);
			//fields.DefineField(AvailableMatchDateFields.VenueId, 1);
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 0, "MinMatchStartTime");
			fields.DefineField(AvailableMatchDateFields.MatchStartTime, 1, "MaxMatchStartTime");
			fields.DefineField(AvailableMatchDateFields.Id, 2, "NumOfDays");
			fields[0].AggregateFunctionToApply = AggregateFunction.Min;
			fields[1].AggregateFunctionToApply = AggregateFunction.Max;
			fields[2].AggregateFunctionToApply = AggregateFunction.Count;
			fields[3].AggregateFunctionToApply = AggregateFunction.None;
			fields[4].AggregateFunctionToApply = AggregateFunction.None;

			IRelationPredicateBucket bucket = new RelationPredicateBucket(AvailableMatchDateFields.TournamentId == _matchPlanner.Tournament.Id);
			bucket.Relations.Add(AvailableMatchDateEntity.Relations.TeamEntityUsingHomeTeamId);
			bucket.PredicateExpression.AddWithAnd(filter);

			IGroupByCollection groupByClause = new GroupByCollection();
			groupByClause.Add(fields[4]);
			groupByClause.Add(fields[3]);

			var dynamicList = new DataTable();
			_matchPlanner.Adapter.FetchTypedList(fields, dynamicList, bucket, 0, null, true, groupByClause);

			return dynamicList;
		}

		[Obsolete("The method is not in use any more in favour of GenerateNew(RoundEntity round).", true)]
		private void GenerateNew()
		{
			if (_matchPlanner.Tournament.TournamentLegs.Count == 0)
				throw new Exception("No legs definded for tournament id " + _matchPlanner.Tournament.Id);

			for (int legCounter = 1; legCounter <= _matchPlanner.Tournament.TournamentLegs.Count; legCounter++)
			{
				var startDateTime = new DateTime();
				var endDateTime = new DateTime();
				var matchDateTime = new DateTime();

                // Get tournament leg date/times
                List<int> found = _matchPlanner.Tournament.TournamentLegs.FindMatches(TournamentLegFields.SequenceNo == legCounter);
                if (found.Count == 1)
                {
                    startDateTime = _matchPlanner.Tournament.TournamentLegs[found[0]].StartDateTime;
                    endDateTime = _matchPlanner.Tournament.TournamentLegs[found[0]].EndDateTime;
                }

				// iterate through all venues related to teams of this tournament
				foreach (var venue in _matchPlanner.Tournament.VenueCollectionViaTeams)
				{
					List<int> teamsList;
					// first: get any team with the current venue
					teamsList = _matchPlanner.Tournament.Teams.FindMatches(TeamFields.VenueId == venue.Id);
					// get all teams with this venue and the same match weekday
					teamsList = _matchPlanner.Tournament.Teams.FindMatches(TeamFields.VenueId == venue.Id & TeamFields.MatchDayOfWeek == (int)_matchPlanner.Tournament.Teams[teamsList[0]].MatchDayOfWeek);

					// get the first possible match date equal or after the leg's starting date
					matchDateTime = IncrementDateUntilDayOfWeek(startDateTime, (DayOfWeek)_matchPlanner.Tournament.Teams[teamsList[0]].MatchDayOfWeek);

					int teamIndex = 0;

					// process the period of a leg
					while (matchDateTime <= endDateTime)
					{
						// if there is more than one team per venue with this weekday,
						// match dates will be assigned alternately
						TeamEntity team = _matchPlanner.Tournament.Teams[teamsList[teamIndex]]; 
						int roundIndex = _matchPlanner.Tournament.Rounds.FindMatches(RoundFields.Id == team.RoundCollectionViaTeamsInRounds[0])[0];
						DateTime dt = DateTime.Parse(string.Concat(matchDateTime.ToShortDateString(), " ", team.MatchTime));

						// check whether the calculated date 
						// is within the borders of round legs (if any) and is not marked as excluded
						if (IsDateWithinRoundLegDateTime(_matchPlanner.Tournament.Rounds[roundIndex].RoundLegs[legCounter - 1], matchDateTime) && !IsExcludedDate(matchDateTime, _matchPlanner.Tournament.Rounds[roundIndex].Id, team.Id))
						{
							var av = new AvailableMatchDateEntity();
							av.TournamentId = _matchPlanner.Tournament.Id;
							av.HomeTeamId = team.Id;
							av.VenueId = venue.Id;
							av.MatchStartTime = DateTime.Parse(string.Concat(matchDateTime.ToShortDateString(), " ", team.MatchTime));
                            av.MatchEndTime = av.MatchStartTime.Add(MatchPlanner.PlannedDurationOfMatch);
							av.IsGenerated = true;
							av.CreatedOn = DateTime.Now;

							_availableMatchDate.Add(av);
							teamIndex = (++teamIndex >= teamsList.Count) ? 0 : teamIndex;
						}
						matchDateTime = matchDateTime.Date.AddDays(7);
					}
				}
			}
			// save to the persistent storage
			_matchPlanner.Adapter.SaveEntityCollection(_availableMatchDate, true, false);
		}
		*/
	}
}