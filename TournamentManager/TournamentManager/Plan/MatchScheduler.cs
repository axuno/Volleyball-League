using TournamentManager.DAL.EntityClasses;
using TournamentManager.DAL.HelperClasses;
using SD.LLBLGen.Pro.ORMSupportClasses;
using System.Collections.ObjectModel;
using Microsoft.Extensions.Logging;
using TournamentManager.MultiTenancy;

namespace TournamentManager.Plan;

/// <summary>
/// Schedules fixtures for all participants of a tournament or round.
/// If the home participant has no venue or home match date/time defined, it will only have away matches.
/// </summary>
internal class MatchScheduler
{
    private readonly ITenantContext _tenantContext;
    private readonly AppDb _appDb;
    private TournamentEntity _tournament = new();
    private readonly ILoggerFactory _loggerFactory;
    private readonly ILogger<MatchScheduler> _logger;
    private readonly AvailableMatchDates _availableMatchDates;
    private bool _areEntitiesLoaded;

    /// <summary>
    /// CTOR.
    /// </summary>
    /// <param name="tenantContext"></param>
    /// <param name="timeZoneConverter"></param>
    /// <param name="loggerFactory"></param>
    public MatchScheduler(ITenantContext tenantContext,
        Axuno.Tools.DateAndTime.TimeZoneConverter timeZoneConverter, ILoggerFactory loggerFactory)
    {
        _tenantContext = tenantContext;
        _appDb = tenantContext.DbContext.AppDb;
        _availableMatchDates = new AvailableMatchDates(tenantContext, timeZoneConverter, loggerFactory.CreateLogger<AvailableMatchDates>());
        _loggerFactory = loggerFactory;
        _logger = loggerFactory.CreateLogger<MatchScheduler>();
    }

    private async Task LoadEntitiesAsync(CancellationToken cancellationToken)
    {
        if (_areEntitiesLoaded) return;
        _tournament = await _appDb.TournamentRepository.GetTournamentEntityForMatchSchedulerAsync(
            _tenantContext.TournamentContext.MatchPlanTournamentId, cancellationToken) ?? throw new InvalidOperationException($"Could not load entity {nameof(TournamentEntity)}");
        _areEntitiesLoaded = true;
    }

    internal async Task GenerateAvailableMatchDatesAsync(MatchDateClearOption clearMatchDates, RoundEntity round,
        EntityCollection<MatchEntity> tournamentMatches, CancellationToken cancellationToken)
    {
        await LoadEntitiesAsync(cancellationToken);
        _ = await _availableMatchDates.ClearAsync(clearMatchDates, cancellationToken);
        await _availableMatchDates.GenerateNewAsync(round, tournamentMatches, cancellationToken);
    }

    /// <summary>
    /// Generates tournament match combinations for the Round Robin system, 
    /// assigns optimized match dates and stores the matches to
    /// the persistent storage.
    /// </summary>
    public async Task ScheduleFixturesForTournament(bool keepExisting, CancellationToken cancellationToken)
    {
        await LoadEntitiesAsync(cancellationToken);

        if (_appDb.MatchRepository.AnyCompleteMatchesExist(_tenantContext.TournamentContext.MatchPlanTournamentId))
            throw new InvalidOperationException("Completed matches exist for this tournament. Generating fixtures aborted.");

        foreach (var round in _tournament.Rounds)
            await ScheduleFixturesForRound(round, keepExisting, cancellationToken);
    }

    /// <summary>
    /// Generates round match combinations for the round-robin system, 
    /// assigns optimized match dates and stores the matches to
    /// the persistent storage.
    /// </summary>
    public async Task ScheduleFixturesForRound(RoundEntity round, bool keepExisting,
        CancellationToken cancellationToken)
    {
        await LoadEntitiesAsync(cancellationToken);

        if (_appDb.MatchRepository.AnyCompleteMatchesExist(round))
            throw new InvalidOperationException($"Completed matches exist for round '{round.Id}'. Generating fixtures aborted.");

        // We load all tournament matches, so that we can check for venues occupied by existing matches in memory.
        var tournamentMatches = await GetOrCreateTournamentMatches(round, keepExisting, cancellationToken);

        await GenerateAvailableMatchDatesAsync(MatchDateClearOption.OnlyAutoGenerated, round, tournamentMatches, cancellationToken);

        var teams = new Collection<long>(round.TeamCollectionViaTeamInRound.Select(t => t.Id).ToList());

        // now calculate matches for each leg of a round
        foreach (var roundLeg in round.RoundLegs)
        {
            var combinations = CreateCombinations(teams, roundLeg);

            HandleTeamsWithoutHomeMatches(round, combinations);

            /*
             * Assign desired time periods for the round turns.
             * These periods are used later to calculate the match dates for the turns.
             */
            AssignTurnDatePeriods(roundLeg, combinations);
            
            // Team combinations (matches) for each turn can take place at the same time.
            // We assign the match dates based on the turn combinations' TurnDateTimePeriods
            foreach (var turn in combinations.GetTurns())
            {
                SetMatchDates(round, roundLeg, turn, combinations, tournamentMatches);
            }
        }

        // save the matches for the group
        await _appDb.GenericRepository.SaveEntitiesAsync(tournamentMatches, true, false, cancellationToken);

        await _availableMatchDates.ClearAsync(MatchDateClearOption.OnlyAutoGenerated, cancellationToken);
    }

    /// <summary>
    /// Sets the match dates for the given <paramref name="combinations"/> in <paramref name="round"/> and <paramref name="roundLeg"/>.
    /// </summary>
    /// <param name="round"></param>
    /// <param name="roundLeg"></param>
    /// <param name="turn"></param>
    /// <param name="combinations"></param>
    /// <param name="tournamentMatches"></param>
    private void SetMatchDates(RoundEntity round, RoundLegEntity roundLeg,
        int turn, ParticipantCombinations<long, long> combinations,
        EntityCollection<MatchEntity> tournamentMatches)
    {
        // Get the selected turn combinations for the given turn.
        var selectedTurnCombinations = combinations.GetCombinations(turn).ToList();

        // Get match dates for every combination of a turn.
        // Matches in the same turnCombinations can even take place at the same time.
        var datesFound = GetMatchDatesForTurn(turn, combinations, tournamentMatches);
        _logger.LogDebug("Found dates for combination: {dates}",
            string.Join(", ",
                    datesFound.OrderBy(bd => bd?.MatchStartTime)
                        .Select(bd => bd?.MatchStartTime.ToShortDateString() ?? "(null)"))
                .Trim(',', ' '));

        // datesFound contains calculated dates in the same sequence as turn combinations,
        // so the index can be used for both.
        for (var index = 0; index < selectedTurnCombinations.Count; index++)
        {
            var combination = selectedTurnCombinations[index];

            // If existing matches were loaded from database, we have to skip such combinations!
            // Note: Home team and guest team of combinations could have been swapped for TeamsWithoutHomeMatches
            if (tournamentMatches.Any(rm =>
                    (rm.HomeTeamId == combination.Home && rm.GuestTeamId == combination.Guest &&
                     rm.LegSequenceNo == roundLeg.SequenceNo) ||
                    (rm.GuestTeamId == combination.Home && rm.HomeTeamId == combination.Guest &&
                     rm.LegSequenceNo == roundLeg.SequenceNo)))
                continue;

            var match = new MatchEntity
            {
                HomeTeamId = combination.Home,
                GuestTeamId = combination.Guest,
                RefereeId = combination.Referee,
                PlannedStart = datesFound[index] != null ? datesFound[index]!.MatchStartTime : default(DateTime?),
                PlannedEnd = datesFound[index] != null
                    ? datesFound[index]!.MatchStartTime
                        .Add(_tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch)
                    : default(DateTime?),
                VenueId = datesFound[index] != null
                    ? datesFound[index]!.VenueId
                    // take over the venue stored in the team entity (may also be null!)
                    : _tournament.Rounds[_tournament.Rounds.FindMatches(RoundFields.Id == roundLeg.RoundId).First()]
                        .TeamCollectionViaTeamInRound.First(t => t.Id == combination.Home).VenueId,
                RoundId = round.Id,
                IsComplete = false,
                LegSequenceNo = roundLeg.SequenceNo,
                ChangeSerial = 0,
                Remarks = string.Empty
            };

            tournamentMatches.Add(match);
            _logger.LogDebug("Fixture completed: {HomeTeam} - {GuestTeam}: {PlannedStart}", match.HomeTeamId,
                match.GuestTeamId, match.PlannedStart);
        }
    }

    /// <summary>
    /// Creates round-robin combinations for the given <paramref name="teams"/> and <paramref name="roundLeg"/>.
    /// </summary>
    /// <param name="teams"></param>
    /// <param name="roundLeg"></param>
    /// <returns>The round-robin combinations for the given <paramref name="teams"></paramref> and <paramref name="roundLeg"/>.</returns>
    private ParticipantCombinations<long, long> CreateCombinations(Collection<long> teams, RoundLegEntity roundLeg)
    {
        // build up match combinations for the teams of round
        var matchCreator = new MatchCreator<long, long>(_tenantContext, _loggerFactory.CreateLogger<MatchCreator<long, long>>());
        var combinations =
            matchCreator.SetParticipants(teams).GetCombinations(
                roundLeg.SequenceNo % 2 == 1 ? LegType.First : LegType.Return);
        return combinations;
    }

    /// <summary>
    /// Gets the existing matches for the given <see cref="RoundEntity.TournamentId"/> of a <paramref name="round"/>.
    /// If <paramref name="keepExistingMatches"/> is <c>true</c>, the existing matches are returned.
    /// If <paramref name="keepExistingMatches"/> is <c>false</c>, the existing matches of the round are deleted before returning tournament matches.
    /// </summary>
    /// <param name="round"></param>
    /// <param name="keepExistingMatches"></param>
    /// <param name="cancellationToken"></param>
    /// <returns>The existing matches for the given <see cref="RoundEntity.TournamentId"/>  <paramref name="round"/>, depending on <paramref name="keepExistingMatches"/>.</returns>
    private async Task<EntityCollection<MatchEntity>> GetOrCreateTournamentMatches(RoundEntity round, bool keepExistingMatches, CancellationToken cancellationToken)
    {
        if (!keepExistingMatches)
        {
            // delete existing matches of the round from storage
            // before load tournament matches
            var bucket = new RelationPredicateBucket(new PredicateExpression(
                new FieldCompareRangePredicate(MatchFields.RoundId, null, false, new[] { round.Id })));
            await _appDb.GenericRepository.DeleteEntitiesDirectlyAsync(typeof(MatchEntity), bucket,
                cancellationToken);
        }

        var tournamentMatches = _appDb.MatchRepository.GetMatches(round.TournamentId!.Value);
        return tournamentMatches;
    }

    /// <summary>
    /// Special treatment for teams which do not have home matches (no venue or no home weekday or time assigned):
    /// Swap home and guest team (keep referee unchanged)
    /// </summary>
    /// <param name="round">The <see cref="RoundEntity"/> the <see cref="ParticipantCombinations{TP,TR}"/> belong to.</param>
    /// <param name="combinations">The combinations for the <see cref="RoundEntity"/>.</param>
    private void HandleTeamsWithoutHomeMatches(RoundEntity round, ParticipantCombinations<long, long> combinations)
    {
        var teamsWithoutHomeMatches = GetTeamsWithoutHomeMatches(round).ToList();

        foreach (var combination in combinations)
        {
            if (!teamsWithoutHomeMatches.Contains(combination.Home)) continue;

            _logger.LogDebug("Team cannot have home matches - {TeamId}. Swap with away team.", combination.Home);

            // swap home and guest team (keep referee unchanged)
            combination.SwapHomeGuest();
        }
    }

    /// <summary>
    /// Gets the match dates that are occupied (i.e. not available) for
    /// the given <paramref name="combination"/> and <paramref name="matches"/>.
    /// </summary>
    /// <param name="combination"></param>
    /// <param name="matches"></param>
    /// <returns>The match dates that are occupied (i.e. not available).</returns>
    private static List<DateTime> GetOccupiedMatchDates(ParticipantCombination<long, long> combination,
        IEnumerable<MatchEntity> matches)
    {
        return (from match in matches
            where
                match.PlannedStart.HasValue && match.PlannedEnd.HasValue &&
                (match.HomeTeamId == combination.Home || match.HomeTeamId == combination.Guest ||
                 match.GuestTeamId == combination.Home || match.GuestTeamId == combination.Guest)
            select match.PlannedStart!.Value.Date).ToList();
    }

    /// <summary>
    /// Gets a lists of available match dates for the given <paramref name="turn"/> of the <paramref name="combinations"/>.
    /// </summary>
    /// <param name="turn"></param>
    /// <param name="combinations"></param>
    /// <param name="roundMatches"></param>
    /// <returns>A lists of available match dates.</returns>
    private List<AvailableMatchDateEntity?> GetMatchDatesForTurn(int turn,
        ParticipantCombinations<long, long> combinations, EntityCollection<MatchEntity> roundMatches)
    {
        var turnCombinations = combinations.GetCombinations(turn).ToList();
        var turnCombinationsPeriod = combinations.TurnDateTimePeriods[turn]!.Value;

        // These are possible date alternatives per combination:
        // Outer list: One item per combination
        // Inner list: The list of date alternatives for the combination
        var matchDates = new List<List<AvailableMatchDateEntity>>();

        for (var index = 0; index < turnCombinations.Count; index++)
        {
            var combination = turnCombinations[index];

            var availableDatesForCombination = _availableMatchDates.GetGeneratedAndManualAvailableMatchDates(combination.Home,
                turnCombinationsPeriod, GetOccupiedMatchDates(combination, roundMatches));
            // initialize MinTimeDiff for the whole list
            availableDatesForCombination.ForEach(amd => amd.MinTimeDiff = TimeSpan.MaxValue);

#if DEBUG
            // Get the last match for at least one of the teams, if any
            var lastMatchOfCombination = roundMatches.OrderBy(gm => gm.PlannedStart).LastOrDefault(gm =>
                gm.HomeTeamId == combination.Home || gm.GuestTeamId == combination.Guest);
            if (lastMatchOfCombination != null)
            {
                _logger.LogDebug("Last match date for home team '{homeTeam}' or guest team '{guestTeam}' is '{plannedStart}'", combination.Home, combination.Guest, lastMatchOfCombination.PlannedStart?.ToShortDateString() ?? "none");
            }
            else
            {
                _logger.LogDebug("No matches yet for home team '{homeTeam}' or guest team '{guestTeam}'", combination.Home, combination.Guest);
            }
#endif
            // If no dates could be found, the date will be set to null.
            if (availableDatesForCombination.Count == 0)
            {
                _logger.LogDebug(
                    "No free dates {from} - {to} found for {home } - {guest}: {period} * will be set to NULL.",
                    turnCombinationsPeriod.Start, turnCombinationsPeriod.End, combination.Home, combination.Guest,
                    turnCombinationsPeriod);
            }

            // We have to add the list of available dates even if it is empty.
            matchDates.Add(availableDatesForCombination);
        }

        return matchDates.Count switch {
            // We can't proceed without any match dates found
            0 => new List<AvailableMatchDateEntity?>(),
            // Only 1 match date found, so optimization is not possible
            // and FindBestDate() would throw an exception
            1 => new List<AvailableMatchDateEntity?> { matchDates[0][0] },
            _ => FindBestDates(matchDates)
        };
    }

    /// <summary>
    /// Finds the best match dates from a list of available match dates for each combination.
    /// The best match is the date that has the smallest distance to the smallest date in the other turn(s).
    /// If no match dates could be determined for a team, bestDate will be set to null.
    /// <para/>
    /// This method is optimizing across all combinations of all turns.
    /// </summary>
    /// <param name="availableMatchDates"></param>
    private static List<AvailableMatchDateEntity?> FindBestDates(List<List<AvailableMatchDateEntity>> availableMatchDates)
    {
        var bestMatchDatesPerCombination = new List<AvailableMatchDateEntity?>();

        // Cross-compute the number of dates between matches of a turn.
        // Goal: Found match dates are as close to each other as possible

        // start with 1st dates, end with last but one dates
        for (var i = 0; i < availableMatchDates.Count - 1; i++)
        {
            // start with 2nd dates, end with last dates
            for (var j = 1; j < availableMatchDates.Count; j++)
            {
                // compare each date in the first list...
                foreach (var dates1 in availableMatchDates[i])
                {
                    // ... with the dates in the second list
                    foreach (var dates2 in availableMatchDates[j])
                    {
                        var daysDiff = Math.Abs((dates1.MatchStartTime.Date - dates2.MatchStartTime.Date).Days);

                        // save minimum dates found for later reference
                        if (daysDiff < dates1.MinTimeDiff.Days)
                            dates1.MinTimeDiff = new TimeSpan(daysDiff, 0, 0, 0);

                        if (daysDiff < dates2.MinTimeDiff.Days)
                            dates2.MinTimeDiff = new TimeSpan(daysDiff, 0, 0, 0);
                    } // end dates2
                } // end dates1
            } // end j

            // Get the date that has the smallest distance to the smallest date in the other turn(s).
            // Note: If no match dates could be determined for a team, bestDate will be null.
            var bestDate = availableMatchDates[i]
                .Where(md => md.MinTimeDiff == availableMatchDates[i]
                    .Min(d => d.MinTimeDiff))
                .MinBy(md => md.MinTimeDiff);
            bestMatchDatesPerCombination.Add(bestDate);

            // process the last combination

            // in case comparisons took place,
            // now the "j-loop" group is not processed yet:
            if (i + 1 >= availableMatchDates.Count - 1)
            {
                bestDate = availableMatchDates[^1]
                    .Where(md => md.MinTimeDiff == availableMatchDates[^1].
                        Min(d => d.MinTimeDiff))
                    .MinBy(md => md.MinTimeDiff);
                // the last "j-increment" is always the same as "matchDates[^1]" (loop condition)
                bestMatchDatesPerCombination.Add(bestDate);
            }
        } // end i

        // returns the best match date found per combination,
        // so the number of elements is the same as the number of combinations
        return bestMatchDatesPerCombination;
    }

    /// <summary>
    /// Desired <see cref="DateTimePeriod"/>s are assigned to round turns mathematically,
    /// spreading match dates equally across the <see cref="RoundLegEntity"/>'s <see cref="RoundLegEntity.StartDateTime"/> and <see cref="RoundLegEntity.EndDateTime"/>.
    /// These periods are used later to calculate the match dates for the turns.
    /// </summary>
    /// <param name="roundLeg">The <see cref="RoundLegEntity"/> to use.</param>
    /// <param name="combinations">The combinations where the <see cref="ParticipantCombinations{TP,TR}.TurnDateTimePeriods"/> will be filled.</param>
    /// <exception cref="InvalidOperationException">Throws if not all round turns got a date period assigned.</exception>
    private void AssignTurnDatePeriods(RoundLegEntity roundLeg,
        ParticipantCombinations<long, long> combinations)
    {
        var allMatchDaysOfRound =
            _availableMatchDates
                .GetGeneratedAndManualAvailableMatchDateDays(roundLeg);

        var periodDaysCount = allMatchDaysOfRound.Count / (combinations.GetTurns().Count() + 1);

        _logger.LogDebug("*** Round: {roundName} - RoundLeg: {legDescription}\n", roundLeg.Round.Name, roundLeg.Description);

        // Initialize the dictionary with the turns and date empty periods
        combinations.TurnDateTimePeriods.Clear();
        foreach (var turn in combinations.GetTurns())
        {
            combinations.TurnDateTimePeriods.Add(turn, null);
        }

        var start = 0;
        var index = 0;
        while (start < allMatchDaysOfRound.Count && index < combinations.TurnDateTimePeriods.Count)
        {
            var end = start + periodDaysCount < allMatchDaysOfRound.Count
                ? start + periodDaysCount
                : allMatchDaysOfRound.Count - 1;

            // Get the key of the dictionary entry at the current index
            var key = combinations.TurnDateTimePeriods.Keys.ElementAt(index);
            combinations.TurnDateTimePeriods[key] =
                new DateTimePeriod(allMatchDaysOfRound[start].Date, allMatchDaysOfRound[end].Date);

            // There could be a remainder of days because of integer division.
            // If there is a gap between the end of the previous turn and the start of the current turn,
            // we adjust the start date of the current turn to the end date of the previous turn + 1 day.
            // Note: The keys (turn numbers) are one-based.
            if (key > 1 && combinations.TurnDateTimePeriods[key]?.Start !=
                combinations.TurnDateTimePeriods[key - 1]?.End?.AddDays(1))
            {
                combinations.TurnDateTimePeriods[key] =
                    new DateTimePeriod(combinations.TurnDateTimePeriods[key - 1]?.End?.AddDays(1),
                                               combinations.TurnDateTimePeriods[key]?.End);
            }

            _logger.LogDebug("Turn #{turn} date period: From={from}, To={to}, {days} days",
                key, combinations.TurnDateTimePeriods[key]?.Start?.ToShortDateString(),
                combinations.TurnDateTimePeriods[key]?.End?.ToShortDateString(),
                (combinations.TurnDateTimePeriods[key]?.End - combinations.TurnDateTimePeriods[key]?.Start)
                ?.Days);

            start = end + 1;
            index++;
        }

        if (combinations.TurnDateTimePeriods.Values.Any(p => p is null))
            throw new InvalidOperationException(
                "Not all round turns got a date period assigned. Probably not enough dates available for assignment.");
    }

    /// <summary>
    /// Gets <see cref="TeamEntity.Id"/>s for the <param name="round"></param> where no home venue or no home match time set for a team.
    /// </summary>
    private static IEnumerable<long> GetTeamsWithoutHomeMatches(RoundEntity round)
    {
        foreach (var team in round.TeamCollectionViaTeamInRound)
        {
            if (team.VenueId == null || team.MatchTime == null || team.MatchDayOfWeek == null)
            {
                yield return team.Id;
            }
        }
    }
}
