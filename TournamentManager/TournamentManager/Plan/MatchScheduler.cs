using TournamentManager.DAL.EntityClasses;
using TournamentManager.DAL.HelperClasses;
using SD.LLBLGen.Pro.ORMSupportClasses;
using System.Collections.ObjectModel;
using Microsoft.Extensions.Logging;
using TournamentManager.MultiTenancy;

namespace TournamentManager.Plan;

/// <summary>
/// Schedules fixtures for all participants of a tournament or round.
/// If the home participant has no venue or home match date/time defined, it will only have away matches.
/// </summary>
internal class MatchScheduler
{
    private readonly ITenantContext _tenantContext;
    private readonly AppDb _appDb;
    private TournamentEntity _tournament = new();
    private readonly ILoggerFactory _loggerFactory;
    private readonly ILogger<MatchScheduler> _logger;
    private readonly AvailableMatchDates _availableMatchDates;
    private readonly Axuno.Tools.DateAndTime.TimeZoneConverter _timeZoneConverter;

    private bool AreEntitiesLoaded { get; set; } = false;

    /// <summary>
    /// CTOR.
    /// </summary>
    /// <param name="tenantContext"></param>
    /// <param name="timeZoneConverter"></param>
    /// <param name="loggerFactory"></param>
    public MatchScheduler(ITenantContext tenantContext,
        Axuno.Tools.DateAndTime.TimeZoneConverter timeZoneConverter, ILoggerFactory loggerFactory)
    {
        _tenantContext = tenantContext;
        _appDb = tenantContext.DbContext.AppDb;
        _timeZoneConverter = timeZoneConverter;
        _availableMatchDates = new AvailableMatchDates(tenantContext, timeZoneConverter, loggerFactory.CreateLogger<AvailableMatchDates>());
        _loggerFactory = loggerFactory;
        _logger = loggerFactory.CreateLogger<MatchScheduler>();
    }

    private async Task LoadEntitiesAsync(CancellationToken cancellationToken)
    {
        _tournament = await _appDb.TournamentRepository.GetTournamentEntityForMatchSchedulerAsync(
            _tenantContext.TournamentContext.MatchPlanTournamentId, cancellationToken) ?? throw new InvalidOperationException($"Could not load entity {nameof(TournamentEntity)}");
        AreEntitiesLoaded = true;
    }

    public async Task GenerateAvailableMatchDatesAsync(MatchDateClearOption clearMatchDates, RoundEntity round,
        CancellationToken cancellationToken)
    {
        _ = await _availableMatchDates.ClearAsync(clearMatchDates, cancellationToken);
        if (!AreEntitiesLoaded) await LoadEntitiesAsync(cancellationToken);
        await _availableMatchDates.GenerateNewAsync(round, cancellationToken);
    }

    /// <summary>
    /// Generates tournament match combinations for the Round Robin system, 
    /// assigns optimized match dates and stores the matches to
    /// the persistent storage.
    /// </summary>
    public async Task ScheduleFixturesForTournament(bool keepExisting, CancellationToken cancellationToken)
    {
        if (!AreEntitiesLoaded) await LoadEntitiesAsync(cancellationToken);

        if (_appDb.MatchRepository.AnyCompleteMatchesExist(_tenantContext.TournamentContext.MatchPlanTournamentId))
            throw new InvalidOperationException("Completed matches exist for this tournament. Generating fixtures aborted.");

        foreach (var round in _tournament.Rounds)
            await ScheduleFixturesForRound(round, keepExisting, cancellationToken);
    }

    /// <summary>
    /// Generates round match combinations for the Round Robin system, 
    /// assigns optimized match dates and stores the matches to
    /// the persistent storage.
    /// </summary>
    public async Task ScheduleFixturesForRound(RoundEntity round, bool keepExisting,
        CancellationToken cancellationToken)
    {
        if (!AreEntitiesLoaded) await LoadEntitiesAsync(cancellationToken);

        if (_appDb.MatchRepository.AnyCompleteMatchesExist(round))
            throw new InvalidOperationException($"Completed matches exist for round '{round.Id}'. Generating fixtures aborted.");

        // generated matches will be stored here
        var roundMatches = new EntityCollection<MatchEntity>();

        if (keepExisting)
        {
            // load existing matches from storage
            roundMatches = _appDb.MatchRepository.GetMatches(round);
        }
        else
        {
            // delete existing matches from storage
            var bucket = new RelationPredicateBucket(new PredicateExpression(
                new FieldCompareRangePredicate(MatchFields.RoundId, null, false, new[] {round.Id})));
            await _appDb.GenericRepository.DeleteEntitiesDirectlyAsync(typeof(MatchEntity), bucket,
                cancellationToken);
        }

        await GenerateAvailableMatchDatesAsync(MatchDateClearOption.OnlyAutoGenerated, round, cancellationToken);

        var teams = new Collection<long>(round.TeamCollectionViaTeamInRound.Select(t => t.Id).ToList());

        // now calculate matches for each leg of a round
        foreach (var roundLeg in round.RoundLegs)
        {
            // build up match combinations for the teams of round
            var matchCreator = new MatchCreator<long>(_tenantContext, _loggerFactory.CreateLogger<MatchCreator<long>>());
            // TODO: RefereeType should be configurable via ITenantContext
            var combinations =
                matchCreator.WithParticipants(teams).GetParticipantCombinations(RefereeType.Home,
                    roundLeg.SequenceNo % 2 == 1 ? LegType.First : LegType.Return);

            /*
             * Special treatment for teams which do not have home matches:
             * swap home and guest team (keep referee unchanged)
             */
            var teamsWithoutHomeMatches = GetTeamsWithoutHomeMatches(round).ToList();

            foreach (var combination in combinations)
            {
                if (!teamsWithoutHomeMatches.Contains(combination.Home)) continue;

                _logger.LogDebug("Team cannot have home matches - {TeamId}. Swap with away team.", combination.Home);

                // swap home and guest team (keep referee unchanged)
                combination.SwapHomeGuest();
            }

            /*
             * Assign desired time periods for the round turns.
             * This is used later to assign dates to the matches.
             */
            AssignRoundDatePeriods(roundLeg, combinations);

            if (combinations.TurnDateTimePeriods.Values.Any(p => p is null))
                throw new InvalidOperationException(
                    "Not all round turns got a date period assigned. Probably not enough dates available for assignment.");

            // Team combinations (matches) for each turn can take place at the same time.
            // We assign the match dates based on the turn combinations' TurnDateTimePeriods
            foreach (var turn in combinations.GetTurns())
            {
                var turnCombinations = combinations.Where(t => t.Turn == turn).ToList();

                // Get match dates for every combination of a group.
                // Matches in the same turnCombinations can even take at the same time.
                // MatchDates contains calculated dates in the same order as combinations,
                // so the index can be used for both.
                var availableDates = GetMatchDates(roundLeg, turnCombinations, combinations.TurnDateTimePeriods[turn]!.Value, roundMatches);
                _logger.LogDebug("Available dates for combination: {dates}", string.Join(", ", availableDates.OrderBy(bd => bd?.MatchStartTime).Select(bd => bd?.MatchStartTime.ToShortDateString())).TrimEnd(',', ' '));

                for (var index = 0; index < turnCombinations.Count; index++)
                {
                    var combination = turnCombinations[index];

                    // If existing matches were loaded from database, we have to skip such combinations!
                    // Note: Home team and guest team of combinations could have been swapped for TeamsWithoutHomeMatches
                    if (roundMatches.Any(rm =>
                            (rm.HomeTeamId == combination.Home && rm.GuestTeamId == combination.Guest &&
                            rm.LegSequenceNo == roundLeg.SequenceNo) ||
                            (rm.GuestTeamId == combination.Home && rm.HomeTeamId == combination.Guest &&
                            rm.LegSequenceNo == roundLeg.SequenceNo)))
                        continue;

                    var match = new MatchEntity
                    {
                        HomeTeamId = combination.Home,
                        GuestTeamId = combination.Guest,
                        RefereeId = combination.Referee,
                        PlannedStart = availableDates[index] != null ? availableDates[index]!.MatchStartTime : default(DateTime?),
                        PlannedEnd = availableDates[index] != null ? availableDates[index]!.MatchStartTime
                            .Add(_tenantContext.TournamentContext.FixtureRuleSet.PlannedDurationOfMatch) : default(DateTime?),
                        VenueId = availableDates[index] != null 
                            ? availableDates[index]!.VenueId
                            // take over the venue stored in the team entity (may also be null!)
                            : _tournament.Rounds[_tournament.Rounds.FindMatches(RoundFields.Id == roundLeg.RoundId).First()].TeamCollectionViaTeamInRound.First(t => t.Id == combination.Home).VenueId,
                        RoundId = round.Id,
                        IsComplete = false,
                        LegSequenceNo = roundLeg.SequenceNo,
                        ChangeSerial = 0,
                        Remarks = string.Empty
                    };

                    _logger.LogDebug("Fixture: {HomeTeam} - {GuestTeam}: {PlannedStart}", match.HomeTeamId, match.GuestTeamId, match.PlannedStart);

                    roundMatches.Add(match);
                }
            }
        }

        // save the matches for the group
        await _appDb.GenericRepository.SaveEntitiesAsync(roundMatches, true, false, cancellationToken);

        await _availableMatchDates.ClearAsync(MatchDateClearOption.OnlyAutoGenerated, cancellationToken);
    }

    private static List<DateTime> GetOccupiedMatchDates(ParticipantCombination<long> combination,
        IEnumerable<MatchEntity> matches)
    {
        return (from match in matches
            where
                match.PlannedStart.HasValue && match.PlannedEnd.HasValue &&
                (match.HomeTeamId == combination.Home || match.HomeTeamId == combination.Guest ||
                 match.GuestTeamId == combination.Home || match.GuestTeamId == combination.Guest)
            select match.PlannedStart!.Value.Date).ToList();
    }


    private List<AvailableMatchDateEntity?> GetMatchDates(RoundLegEntity roundLeg,
        List<ParticipantCombination<long>> turnCombinations, DateTimePeriod turnCombinationsPeriod, EntityCollection<MatchEntity> roundMatches)
    {
        // The resulting match dates are stored here
        var matchDatesPerCombination = new List<AvailableMatchDateEntity?>();

        // These are possible date alternatives per combination:
        var matchDates = new List<List<AvailableMatchDateEntity>>();

        for (var index = 0; index < turnCombinations.Count; index++)
        {
            var combination = turnCombinations[index];

            var availableDates = _availableMatchDates.GetGeneratedAndManualAvailableMatchDates(combination.Home,
                turnCombinationsPeriod, GetOccupiedMatchDates(combination, roundMatches));
            // initialize MinTimeDiff for the whole list
            availableDates.ForEach(amd => amd.MinTimeDiff = TimeSpan.MaxValue);
            // if no dates could be found, try to find dates within the whole round leg
            if (availableDates.Count == 0)
            {
                _logger.LogDebug("No dates found for {home } - {guest}: {period} * Now using full round leg period.", combination.Home, combination.Guest, turnCombinationsPeriod);
                availableDates = _availableMatchDates.GetGeneratedAndManualAvailableMatchDates(combination.Home,
                    new DateTimePeriod(roundLeg.StartDateTime, roundLeg.EndDateTime),
                    GetOccupiedMatchDates(combination, roundMatches));
            }
            
            matchDates.Add(availableDates);

#if DEBUG
            // Show the last match for at least one of the teams, if any
            var lastMatchOfCombination = roundMatches.OrderBy(gm => gm.PlannedStart).LastOrDefault(gm =>
                gm.HomeTeamId == combination.Home || gm.GuestTeamId == combination.Guest);
            if (lastMatchOfCombination != null)
            {
                _logger.LogDebug("Last match date found for home team '{homeTeam}' or guest team '{guestTeam}' is '{plannedStart}'", combination.Home, combination.Guest, lastMatchOfCombination.PlannedStart?.ToShortDateString() ?? "none");
            }
            else
            {
                _logger.LogDebug("No last match found for home team '{homeTeam}' or guest team '{guestTeam}'", combination.Home, combination.Guest);
            }
#endif
        }

        // we can't proceed without any match dates found
        if (matchDates.Count == 0) return matchDatesPerCombination;

        // only 1 match date found, so optimization is not possible
        // and the following "i-loop" will be skipped
        if (matchDates.Count == 1)
        {
            matchDatesPerCombination.Add(matchDates[0][0]);
            return matchDatesPerCombination;
        }

        // Cross-compute the number of dates between between matches of turn.
        // Goal: found match dates should be as close together as possible

        // start with 1st dates, end with last but one dates
        for (var i = 0; i < matchDates.Count - 1; i++)
        {
            // start with 2nd dates, end with last dates
            for (var j = 1; j < matchDates.Count; j++)
            {
                // compare each date in the first list...
                foreach (var dates1 in matchDates[i])
                {
                    // ... with the dates in the second list
                    foreach (var dates2 in matchDates[j])
                    {
                        var daysDiff = Math.Abs((dates1.MatchStartTime.Date - dates2.MatchStartTime.Date).Days);

                        // save minimum dates found for later reference
                        if (daysDiff < dates1.MinTimeDiff.Days)
                            dates1.MinTimeDiff = new TimeSpan(daysDiff, 0, 0, 0);

                        if (daysDiff < dates2.MinTimeDiff.Days)
                            dates2.MinTimeDiff = new TimeSpan(daysDiff, 0, 0, 0);
                    } // end dates2
                } // end dates1
            } // end j

            // Get the date that has least distance to smallest date in other turn(s)
            // Note: If no match dates could be determined for a team, bestDate will be null.
            var bestDate = matchDates[i].Where(md => md.MinTimeDiff == matchDates[i].Min(d => d.MinTimeDiff))
                .OrderBy(md => md.MinTimeDiff).FirstOrDefault();
            matchDatesPerCombination.Add(bestDate);

            // process the last combination

            // in case comparisons took place,
            // now the "j-loop" group is not processed yet:
            if (i + 1 >= matchDates.Count - 1)
            {
                bestDate = matchDates[^1].Where(md => md.MinTimeDiff == matchDates[^1].Min(d => d.MinTimeDiff))
                    .MinBy(md => md.MinTimeDiff);
                // the last "j-increment" is always the same as "matchDates[^1]" (loop condition)
                matchDatesPerCombination.Add(bestDate);
            }
        } // end i

        return matchDatesPerCombination;
    }

    /// <summary>
    /// Desired <see cref="DateTimePeriod"/>s are assigned to round turns purely mathematically,
    /// spreading match dates equally across the <see cref="RoundLegEntity"/>'s <see cref="RoundLegEntity.StartDateTime"/> and <see cref="RoundLegEntity.EndDateTime"/>.
    /// </summary>
    /// <param name="roundLeg">The <see cref="RoundLegEntity"/> to use.</param>
    /// <param name="combinations">The combinations where the <see cref="ParticipantCombinations{T}.TurnDateTimePeriods"/> will be filled.</param>
    private void AssignRoundDatePeriods(RoundLegEntity roundLeg,
        ParticipantCombinations<long> combinations)
    {
        var allMatchDaysOfRound =
            _availableMatchDates
                .GetGeneratedAndManualAvailableMatchDateDays(roundLeg);

        var periodDaysCount = allMatchDaysOfRound.Count / (combinations.GetTurns().Count() + 1);

        _logger.LogDebug("*** Round: {roundName} - RoundLeg: {legDescription}\n", roundLeg.Round.Name, roundLeg.Description);

        // Initialize the dictionary with the turns and date empty periods
        combinations.TurnDateTimePeriods.Clear();
        foreach (var turn in combinations.GetTurns())
        {
            combinations.TurnDateTimePeriods.Add(turn, null);
        }

        var start = 0;
        var index = 0;
        while (start < allMatchDaysOfRound.Count && index < combinations.TurnDateTimePeriods.Count)
        {
            //TODO: There could be a remainder of days because of integer division!
            var end = start + periodDaysCount < allMatchDaysOfRound.Count
                ? start + periodDaysCount
                : allMatchDaysOfRound.Count - 1;

            // Get the key of the dictionary entry at the current index
            var key = combinations.TurnDateTimePeriods.Keys.ElementAt(index);
            combinations.TurnDateTimePeriods[key] =
                new DateTimePeriod(allMatchDaysOfRound[start].Date, allMatchDaysOfRound[end].Date);

            _logger.LogDebug("Turn #{turn} date period: From={from}, To={to}, {days} days",
                key, combinations.TurnDateTimePeriods[key]?.Start?.ToShortDateString(),
                combinations.TurnDateTimePeriods[key]?.End?.ToShortDateString(),
                (combinations.TurnDateTimePeriods[key]?.End - combinations.TurnDateTimePeriods[key]?.Start)
                ?.Days);

            start = end + 1;
            index++;
        }
    }

    /// <summary>
    /// Gets <see cref="TeamEntity.Id"/>s for the <param name="round"></param> where no home venue or no home match time set for a team.
    /// </summary>
    private static IEnumerable<long> GetTeamsWithoutHomeMatches(RoundEntity round)
    {
        foreach (var team in round.TeamCollectionViaTeamInRound)
        {
            if (team.VenueId == null || team.MatchTime == null || team.MatchDayOfWeek == null)
            {
                yield return team.Id;
            }
        }
    }
}
